Ниже — переписанный блок, заточенный под LM как “калькулятор/аналитический движок”, с явным акцентом на статистику и прогнозирование: зачем он тебе, как именно даёт прирост по метрикам, что пишет в LM_value. Можно вставлять в документ вместо старой вставки.

⸻

3.x. Слой LM (аналитическая модель) и таблица LM_value

Роль LM в Operabot: что он даёт по факту

LM в контексте Operabot — это не языковая модель, а отдельный аналитический слой поверх MySQL, который:
	1.	Делает статистический анализ
	•	считает нормализованные метрики по каждому звонку, оператору, услуге, источнику трафика;
	•	даёт стабильные KPI: конверсию, потери, нагрузку, качество обработки, распределения по времени, по каналам и т.п.
	2.	Строит прогнозы
	•	прогнозирует объём и структуру звонков (по дням недели, по часам, по каналам);
	•	прогнозирует конверсию и риск потерь (по оператору, по услуге, по источнику);
	•	позволяет заранее видеть, где “просядут” метрики и где полезно вмешаться.
	3.	Обогащает метрики для дашбордов и ML
	•	превращает сырые поля call_history / call_scores в скоринговые индексы и флаги, которые легко агрегировать;
	•	даёт “готовые” числовые фичи для ML-модулей (прогноз оттока, риска жалобы и т.п.).
	4.	Служит базой для управленческих решений
	•	позволяет отвечать на вопросы “что будет, если…” (смена скрипта, акций, расписания операторов);
	•	даёт объективную базу для контроля операторов и роста качества.

Чтобы это всё работало, нужен единый реестр результатов расчётов LM — таблица LM_value.

⸻

Задача LM_value

У тебя уже есть:
	•	call_history — сырые факты по звонку (кто, когда, длительность, статусы, расшифровка и т.д.);
	•	call_scores — “человеческая” оценка/разметка звонка (целевой/нецелевой, исход, категория, услуга, врач, чек-листы, общий call_score и т.п.).

LM_value — это третий слой, куда складывается всё, что насчитала LM по конкретному звонку:
	•	нормализованные численные метрики (скоринги, индексы, вероятности);
	•	категориальные признаки (класс риска, тип кейса, флаг «Нужно перезвонить» и т.п.);
	•	вспомогательные агрегаты в виде JSON (мелкие флаги/фичи без PII).

Важное: LM_value — про цифры и фичи, а не про текст и не про GPT.

⸻

Типы значений в LM_value с учётом статистики и прогнозов

Группы метрик, чтобы было понятно “зачем” каждая:

1. Операционные метрики (metric_group = 'operational')
Цель: понимать нагрузку, эффективность работы линии и операторов.

Основаны на call_history и call_scores:
	•	response_speed_score — скорость реакции (функция от await_sec, времени звонка, SLA).
	•	talk_time_efficiency — насколько эффективно использовали разговор (функция от talk_duration, duration, исхода outcome).
	•	queue_impact_index — нагрузка на линию (учёт длительности, времени, типа звонка).

Применение:
	•	стат анализ: средние/перцентили по операторам, по часам, по дням недели;
	•	прогноз: на основе истории queue_impact_index можно строить прогноз пиковых нагрузок.

2. Конверсионные/бизнес-метрики (metric_group = 'conversion')
Цель: деньги и заявки.

Основаны на is_target, outcome, call_category, requested_service_id и т.п.:
	•	conversion_score — оценка/вероятность того, что звонок превратился или превратится в запись (0–1 или 0–100).
	•	lost_opportunity_score — “цена потери” при outcome != 'record' (учёт refusal_reason, типа услуги, потенциального чека).
	•	cross_sell_potential — потенциал допродажи по звонку (по категории/услуге).

Применение:
	•	стат анализ: сравнение операторов, услуг, источников по конверсии и потерям;
	•	прогноз: на базе истории conversion_score и объёмов звонков — прогноз количества записей/выручки по дням/неделям.

3. Качество обработки звонка (metric_group = 'quality')
Цель: управление качеством работы операторов.

LM — не GPT, а “агрегатор чисел”:
	•	checklist_coverage_ratio — покрытие чек-листа (функция от number_checklist, category_checklist, веса пунктов).
	•	normalized_call_score — call_score, приведённый к единой шкале (0–1 / 0–100) с учётом калибровки.
	•	script_risk_index — риск нарушения скрипта (по call_type, context_type, call_category и др. сигналам).

Применение:
	•	стат анализ: распределения normalized_call_score по операторам, по типам звонков, по каналам;
	•	прогноз: “если ничего не менять”, предсказать средний скор качества по отделу/оператору на период.

4. Риски и флаги (metric_group = 'risk')
Цель: раннее выявление проблем.
	•	churn_risk_level (low / medium / high) — риск не вернуться, исходя из результата, отказа, типа услуги.
	•	complaint_risk_flag (true/false) — флаг потенциальной жалобы (по call_category, refusal_reason, техническим признакам).
	•	followup_needed_flag — флаг «Нужно перезвонить» (по логике LM).

Применение:
	•	стат анализ: доля звонков с высоким риском по оператору/каналу;
	•	прогноз: ожидаемое количество “проблемных” кейсов на неделю вперёд.

5. Метрики прогноза (metric_group = 'forecast')
Цель: подкрутить планирование и загрузку.

Здесь LM выступает как прогностическая модель на уровне звонка — оценивает “будущее поведение” этого звонка/клиента:
	•	conversion_prob_forecast — вероятностный прогноз, что по этому звонку всё-таки будет запись (если сейчас не записались).
	•	second_call_prob — вероятность повторного звонка.
	•	complaint_prob — вероятность, что это перерастёт в жалобу.

Дальше уже ты агрегируешь эти значения по дням/операторам/услугам и получаешь прогнозы: сколько будет повторных звонков, каких рисков ждать и т.п.

6. Технические/вспомогательные метрики LM (metric_group = 'aux')
Цель: прозрачность и управляемость самого LM.
	•	lm_version — версия правил/модели, по которой считались значения.
	•	calc_profile — код сценария: default_v1, campaign_2025Q1, night_shift_v1 и т.д.
	•	feature_pack — JSON с компактным набором фич (без PII), если нужно хранить “слепок” входных признаков для отладки.

⸻

Структура таблицы LM_value

CREATE TABLE lm_value (
    id               BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    
    -- Связь с звонком / оценкой
    history_id       INT UNSIGNED    NOT NULL,  -- FK -> call_history.history_id
    call_score_id    INT UNSIGNED    NULL,      -- FK -> call_scores.id (опционально)
    
    -- Семантика метрики
    metric_code      VARCHAR(64)     NOT NULL,  -- 'conversion_score', 'churn_risk_level', ...
    metric_group     VARCHAR(32)     NOT NULL,  -- 'operational', 'conversion', 'quality', 'risk', 'forecast', 'aux'
    
    -- Значения (одно или несколько полей)
    value_numeric    DECIMAL(10,4)   NULL,      -- скор, коэффициент, вероятность
    value_label      VARCHAR(255)    NULL,      -- 'low', 'high', 'record', 'true', ...
    value_json       JSON            NULL,      -- компактный набор признаков/флагов без PII
    
    -- Метаданные расчёта (только про LM)
    lm_version       VARCHAR(32)     NOT NULL,  -- 'lm_v1', 'rules_2025_01', ...
    calc_method      VARCHAR(32)     NOT NULL,  -- 'rule', 'tree', 'gbm', 'regression', ...
    calc_source      VARCHAR(64)     NULL,      -- 'cron_daily_scoring', 'online_scoring', 'backfill_2025_01'
    
    created_at       DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at       DATETIME        NULL ON UPDATE CURRENT_TIMESTAMP,
    
    PRIMARY KEY (id),
    
    -- Один звонок + одна метрика → одна строка
    UNIQUE KEY uq_lm_value_history_metric (history_id, metric_code),
    
    KEY idx_lm_value_history      (history_id),
    KEY idx_lm_value_call_score   (call_score_id),
    KEY idx_lm_value_metric_group (metric_group),
    
    CONSTRAINT fk_lm_value_call_history
        FOREIGN KEY (history_id)  REFERENCES call_history (history_id),
    CONSTRAINT fk_lm_value_call_scores
        FOREIGN KEY (call_score_id) REFERENCES call_scores (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

Смысл:
	•	по строкам: один звонок × одна метрика LM;
	•	по колонкам:
	•	metric_code говорит, что за метрика;
	•	metric_group группирует по назначению (операционные, конверсия, качество, риски, прогноз, техн.);
	•	value_numeric / value_label / value_json — сами значения, которые потом агрегируются в отчётах;
	•	lm_version, calc_method, calc_source позволяют понимать, чем и как посчитано.

⸻

Как LM и LM_value работают в цепочке “анализ → прогноз → управление”
	1.	LM-сервис читает сырые данные
	•	из call_history — факты (время, длительность, статусы, категории);
	•	из call_scores — оценки (целевой/нецелевой, исход, услуга, чек-листы, call_score).
	2.	LM считает метрики
	•	по правилам/моделям строит response_speed_score, conversion_score, churn_risk_level, conversion_prob_forecast и т.д.;
	•	результаты пишет в LM_value (одна строка на metric_code).
	3.	Статистика и мониторинг
	•	metrics_calculator.py и weekly_quality_service.py делают обычные SQL-агрегаты по LM_value + call_scores:
	•	средние/перцентили по метрикам;
	•	сравнение операторов/каналов/услуг;
	•	динамика по дням/неделям (через call_date из call_scores + LM_value).
	4.	Прогнозирование
	•	на истории LM_value + call_scores строятся модели прогнозов (объёмы звонков, конверсия, риск, нагрузка);
	•	прогнозы могут:
	•	либо считаться “на лету” и возвращаться в отчёты,
	•	либо записываться в отдельные вью/таблицы (например, vw_lm_daily_stats, если захочешь материализовать).
	5.	Использование в решениях
	•	менеджеры видят: “через неделю с теми же операторами и скриптами у нас будет X заявок, Y потерянных, Z рисковых кейсов”;
	•	можно заранее:
	•	подкрутить скрипты,
	•	перераспределить смены операторов,
	•	врубить акции или напротив притормозить трафик.

⸻

Как это вписать в общий план

В текущем документе:
	1.	Блок назвать, например:

3.x. Слой LM (статистика и прогнозирование) и таблица LM_value

	2.	В разделе “3. Интеграция с БД” дописать:

“Результаты вычислений LM (операционные, конверсионные, качественные, риск- и прогнозные метрики) по каждому звонку сохраняются в таблицу LM_value в узком формате metric_code → value_numeric/value_label/value_json с привязкой к call_history.history_id и, при необходимости, к call_scores.id.”

	3.	В разделе про аналитику/ML указать, что все продвинутые дашборды и прогнозы строятся уже не на сырых полях, а на слое LM_value — это и есть твой “калькулятор на максималках”.

Если хочешь, следующим шагом могу набросать отдельную таблицу-справочник lm_metric_dictionary с описанием всех metric_code (тип, формула, где используется), чтобы закрепить это как “официальный словарь метрик”.
