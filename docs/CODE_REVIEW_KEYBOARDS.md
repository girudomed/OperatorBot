# Code Review: Кнопки и Клавиатуры (Final)

## 1. Текущее состояние
Код запускается, фатальных ошибок архитектуры нет, но присутствует "мёртвый код" и отсутствуют жесткие стандарты именования callback-ов.

## 2. Основные факты и риски

### 2.1. Дублирование реализации (Dead Code vs Active Code)
В проекте обнаружены две версии админ-панели:
1.  **Активная:** `app/telegram/handlers/admin_panel.py` — зарегистрирована в `app/main.py` и обрабатывает боевой трафик.
2.  **Неактивная:** `app/telegram/handlers/admin_menu.py` — файл существует, но **не импортируется и не регистрируется** в `main.py`.

**Риск:**
Наличие "мёртвой" копии `admin_menu.py` (которая визуально выглядит как улучшенная версия с "LM Метриками") вводит в заблуждение. Разработчик может вносить правки туда, ожидая изменений на проде, и не понимать, почему ничего не меняется. Или наоборот — может случайно переключить импорт в `main.py`, получив непредвиденное изменение UI.

### 2.2. Стандарты Callback Data
В активном коде (`admin_panel.py`, `admin_users.py`) callback-и формируются разными способами:
*   Где-то вручную через f-строки: `f"admin:users:details:{...}"`.
*   Где-то через helper-методы: `self._callback(...)`.

**Риск:**
Отсутствие централизованного механизма `pack/unpack` (кодирования/декодирования) приводит к потенциальным проблемам:
*   Ошибки парсинга (если разделитель `:` окажется внутри параметра).
*   Нет явного контроля длины (Telegram limit 64 bytes).
*   "Магические строки" разбросаны по коду, что усложняет рефакторинг.

## 3. Рекомендации (Refactoring Plan)

### Этап 1: Внедрение Codec для Callback Data
Вместо простых констант внедрить механизм `pack/unpack` с валидацией.

```python
# Пример концепции
class AdminCB:
    PREFIX = "adm"
    
    @staticmethod
    def pack(action: str, *args) -> str:
        # 1. Проверка длины
        # 2. Сборка строки "adm:act:arg1:arg2"
        return encoded_str

    @staticmethod
    def unpack(data: str) -> tuple[str, list[str]]:
        # Парсинг и валидация префикса
        return action, args
```

**Критерий успеха:** Исключение возможности создать валидный с виду, но нерабочий callback (слишком длинный или с неверным форматом).

### Этап 2: Устранение дублирования
Так как `admin_menu.py` сейчас не используется:
1.  **Вариант А (Простой):** Удалить `admin_menu.py` во избежание путаницы, предварительно перенеся уникальные фичи (кнопка "LM Метрики") в активный `admin_panel.py`.
2.  **Вариант Б (Миграция):** Если `admin_menu.py` планировался как "новая архитектура", то доработать его, зарегистрировать в `main.py` вместо `admin_panel.py`, а старый файл удалить.

*Рекомендую Вариант А для быстрой стабилизации.*

### Этап 3: Совместимость (Backward Compatibility)
При изменении формата callback_data (например, переходе на короткие алиасы `adm:usr` вместо `admin:users`):
*   Необходимо поддерживать старые форматы парсинга в течение 1-2 релизов, так как у пользователей могут остаться старые сообщения с кнопками в чате.
*   Если старый callback прилетает -> обрабатываем его по старой логике или мягко предлагаем "Обновить меню".

### Этап 4: Server-side State (High Load / Complex Filters)
Внедрять серверное состояние (хранение параметров в Redis/Memory по ID) только если:
*   Длина `callback_data` начинает превышать 40-50 байт.
*   Требуется передавать сложный контекст (много фильтров, поисковые запросы).
В остальных случаях (простая пагинация, ID юзера) оставлять данные в кнопке (Stateless), чтобы не усложнять архитектуру.
