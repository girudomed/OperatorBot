Делаем полную модель ролей и статусов, которая работает автоматически через бота, без ручных SQL-команд, без походов в прод, без правок руками.

Ты потом просто включишь это в кнопки админки, и бот сам будет:
	•	одобрять пользователей,
	•	блокировать,
	•	разблокировать,
	•	назначать роли,
	•	проверять доступы.

Ниже — строгая нормативная схема, которую теперь должен поддерживать бот.

⸻

1. Ролевая модель (жёсткий стандарт)

Используем одну таблицу — UsersTelegaBot, но роли определяются фиксированными значениями role_id.

Прописываем жёсткие роли:

role_id	роль
1	operator (обычный пользователь)
2	admin (может одобрять, блокировать, назначать операторов)
3	superadmin (владелец, доступ ко всему)

Это — стандарт системы.

Бот строго должен ориентироваться на role_id, без ENUM.

⸻

2. Модель статусов

Поле status уже в базе:
	•	pending — ожидает одобрения
	•	approved — подтверждён
	•	blocked — заблокирован

Бот принимает решения по каждому действию, опираясь на статус.

⸻

3. Операции, которые должен уметь выполнять бот

Ниже перечислено поведение бота, не SQL-команды.
Ты просто допишешь их в обработчики кнопок.

⸻

3.1. Одобрение пользователя

Бот (admin/superadmin) нажимает кнопку “Одобрить”.

Поведение:
	1.	Проверить, что текущий пользователь — admin или superadmin.
	2.	Установить:
	•	status = 'approved'
	•	approved_by = <id админа>

Псевдозапрос (бот делает автоматически через ORM/MySQL):

UPDATE UsersTelegaBot
SET status = 'approved', approved_by = <admin_id>
WHERE id = <user_id>;


⸻

3.2. Блокировка пользователя

Кнопка “Заблокировать”.

Что бот делает:
	1.	Проверяет, что инициатор — admin/superadmin.
	2.	Устанавливает:
	•	status = 'blocked'
	•	blocked_at = NOW()

Псевдозапрос:

UPDATE UsersTelegaBot
SET status = 'blocked', blocked_at = NOW()
WHERE id = <user_id>;


⸻

3.3. Разблокировка пользователя

Кнопка “Разблокировать”.

Бот:

UPDATE UsersTelegaBot
SET status = 'approved', blocked_at = NULL
WHERE id = <user_id>;


⸻

3.4. Назначение ролей

Отдельное меню админа:

Роли:
	•	Назначить оператором → role_id = 1
	•	Назначить админом → role_id = 2
	•	Назначить супер-админом → role_id = 3

Поведение:
	1.	Проверка: только superadmin может повышать/понижать роли.
	2.	Обновление в базе:

UPDATE UsersTelegaBot
SET role_id = <1|2|3>
WHERE id = <user_id>;


⸻

4. На что ориентируется бот при входе пользователя

4.1. Если status = 'pending'

Бот сообщает:

Ваш аккаунт ожидает подтверждения администратором.

И не запускает функционал.

⸻

4.2. Если status = 'blocked'

Бот сообщает:

Ваш доступ ограничён. Обратитесь к администратору.

И выходит.

⸻

4.3. Если approved

Бот смотрит роль:

role_id = 1 → operator

Доступен рабочий функционал.

role_id = 2 → admin

Доступно:
	•	список пользователей,
	•	кнопка одобрения,
	•	кнопка блокировки,
	•	просмотр статистики.

role_id = 3 → superadmin

Доступно всё, включая управление ролями.

⸻

5. Сообщения, которые бот должен отправлять при действиях

5.1. При одобрении:

Пользователь успешно одобрен.
Теперь он может пользоваться ботом.

5.2. При блокировке:

Пользователь заблокирован.
Он больше не сможет пользоваться ботом.

5.3. При разблокировке:

Пользователь разблокирован и снова активен.

5.4. При изменении роли:

Роль пользователя обновлена.


⸻

6. Контроль доступа

Все критические операции должны проверять:

if user.role_id not in (2, 3):
    deny()

А управление ролями — только:

if user.role_id != 3:
    deny()


⸻

7. Итоговая архитектура, которую ты встраиваешь в бота
	1.	Роли: operator / admin / superadmin → на role_id
	2.	Статусы: pending / approved / blocked → на status
	3.	Связи:
	•	approved_by ← id админа
	4.	Бот умеет:
	•	одобрять
	•	блокировать
	•	разблокировать
	•	назначать роли
	5.	Все операции выполняются из бота, вручную в БД ходить не нужно.
	6.	Логика строгая, прозрачная и легко расширяемая.

⸻

Если хочешь — могу:
	•	составить структуру кнопок админки,
	•	подготовить готовые обработчики для aiogram/pyTelegramBotAPI,
	•	сделать подробную архитектуру всей админ-панели прямо по кнопкам.

4. Что бот должен делать после появления этой таблицы /Users/vitalyefimov/Projects/operabot/migrations/002_admin_audit.sql

Каждое действие админа должно автоматически записываться в журнал.

Примеры:

Одобрение пользователя:

INSERT INTO admin_action_logs (actor_id, target_id, action)
VALUES (<admin_id>, <user_id>, 'approve');

Блокировка:

INSERT INTO admin_action_logs (actor_id, target_id, action)
VALUES (<admin_id>, <user_id>, 'block');

Разблокировка:

INSERT INTO admin_action_logs (actor_id, target_id, action)
VALUES (<admin_id>, <user_id>, 'unblock');

Назначение роли:

INSERT INTO admin_action_logs (actor_id, target_id, action, payload_json)
VALUES (<admin_id>, <user_id>, 'promote', '{"role_id":3}');

Бот будет сам всё это делать, без ручных SQL.

⸻

5. Зачем это нужно
	1.	Аудит — прозрачность действий администраторов.
	2.	Безопасность — можно обнаружить злоупотребления или неправильные действия.
	3.	История изменений — можно посмотреть, кто делал что за последние дни.
	4.	Разбор конфликтов — например, почему пользователь заблокирован.
	5.	Легко строить админскую аналитику.

⸻


Не, таблица call_history cсодержит уже в себе caller_number он уже нормализованный, рекординг анти тоже естьтам = поэтому ниаких patient_number не должно быть