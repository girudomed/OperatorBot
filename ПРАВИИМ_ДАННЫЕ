


Колонка created_at в call_history у тебя есть — это видно по структуре. Значит ошибка:

Unknown column 'created_at' in 'field list'

возникает не потому что колонки нет в call_history, а потому что в реальном SQL, который выполняет ETL, created_at берётся не из call_history (или вообще запрос идёт не в ту таблицу/схему), либо берётся без алиаса и попадает “в поле” другого источника.

Ключевая улика: MySQL пишет in 'field list' — это обычно SELECT-часть, а не WHERE. Если бы не было created_at в условии, чаще было бы in 'where clause'.

Ниже — как чинить точно и по делу.

⸻

1) Проверь и выровняй реальный SQL ETL

Где править

app/services/call_analytics_sync.py, метод sync_new() (у тебя в логе именно он).

Что искать в файле
	•	Любой SELECT ... created_at ...
	•	Любой MAX(created_at) / ORDER BY created_at
	•	Любые подзапросы, где created_at выбирается из не той таблицы
	•	Частая ошибка: SELECT id, created_at ... FROM call_history — а у тебя нет id, у тебя PK = history_id

Правильный минимальный инкрементальный запрос (под твою call_history)

Используй явный алиас и выбирай реальные поля:

SELECT
  ch.history_id,
  ch.created_at,
  ch.updated_at,
  ch.entry_id,
  ch.recording_id,
  ch.caller_number,
  ch.called_number,
  ch.talk_duration,
  ch.await_sec,
  ch.context_start_time_dt,
  ch.answered_extension,
  ch.answered_user_id,
  ch.transcript
FROM call_history ch
WHERE ch.created_at > %s
ORDER BY ch.created_at ASC
LIMIT %s;

Важно:
	•	Везде ch.created_at, не просто created_at
	•	Не использовать id (его нет)
	•	Ключ записи — history_id

Если тебе нужен “timestamp звонка” вместо времени вставки, можно менять на:
	•	ch.context_start_time_dt (у тебя есть)
	•	или ch.context_ts (у тебя есть)

Но сейчас именно created_at есть и индекс на нём есть (idx_ch_created) — это ок для инкремента.

⸻

2) Почему при наличии created_at всё равно падает: 2 самые вероятные причины

Причина A (самая частая): created_at выбирается из другой таблицы (например call_scores)

У тебя call_scores не содержит created_at. Если ETL делает JOIN и ты где-то написал:
	•	SELECT cs.created_at ... → упадёт
	•	SELECT created_at ... без префикса → может “прилипнуть” к cs/derived table и упасть

✅ Фикс: в SELECT/ORDER BY всегда ch.created_at, а не created_at и не cs.created_at.

⸻

Причина B: ETL подключается не к той БД/схеме (или другая call_history без created_at)

Ты пишешь “БД одна”, но на практике часто:
	•	бот ходит в другой DB_NAME
	•	или другой хост/юзер с другим default schema
	•	или есть таблица call_history в другом schema без created_at

✅ Фикс (в коде, без гаданий): при старте приложения 1 раз логируй, куда реально подключился:

SELECT DATABASE() as db;
SHOW COLUMNS FROM call_history LIKE 'created_at';

Или через information_schema:

SELECT COUNT(*) as cnt
FROM information_schema.COLUMNS
WHERE TABLE_SCHEMA = DATABASE()
  AND TABLE_NAME = 'call_history'
  AND COLUMN_NAME = 'created_at';

Если cnt=0 — значит бот реально работает с другой таблицей/схемой.

⸻

3) Добавь “контракт схемы” прямо в код ETL, чтобы такое не повторялось

В call_analytics_sync.py перед первым инкрементом (или один раз на старте сервиса):
	1.	Проверить наличие обязательных колонок:

	•	history_id
	•	created_at
	•	updated_at

	2.	Если чего-то нет — логировать 1 раз и не падать (остановить ETL, но бот живёт).

Это уберёт “рандомные” падения при несовпадении схем.

⸻

4) Критерий приёмки (конкретный)

После правки:
	1.	В логах нет:

	•	Unknown column 'created_at' in 'field list'

	2.	ETL пишет:

	•	старт инкремента
	•	количество выбранных строк > 0 (когда есть новые)

	3.	sync_new не трогает id (потому что его нет), использует history_id

⸻

Быстрый чек-лист: что именно править в твоём случае
	1.	В call_analytics_sync.py:

	•	заменить любые SELECT id, ... → SELECT history_id, ...
	•	заменить любые created_at без префикса → ch.created_at
	•	исключить cs.created_at (в call_scores его нет)

	2.	Добавить лог SELECT DATABASE() при старте пула (один раз).

⸻

Если вставишь сюда реальный SQL, который ETL выполняет (кусок из call_analytics_sync.py, 30–80 строк вокруг запроса) — я дам патч “замени строки X–Y на …” без вариантов.